from flask import request, redirect, url_for, send_file, flash
from bs4 import BeautifulSoup
import os
import hashlib
import secrets
import requests
import ipinfo
import pandas as pd
import yaml
import io

def download_datastore_in_specific_format(datastore, target_format):
    df = datastore.read_data()
    buffer = io.BytesIO()
    if target_format == 'excel':
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Sheet1')
        buffer.seek(0)
        return send_file(buffer, as_attachment=True, download_name="data.xlsx", mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    elif target_format == 'parquet':
        df.to_parquet(buffer, index=False)
        buffer.seek(0)
        return send_file(buffer, as_attachment=True, download_name="data.parquet", mimetype="application/octet-stream")
    elif target_format == 'json':
        return df.to_json(orient='records',indent=4), 200, {'Content-Type': 'application/json'}
    else:
        flash('Unsupported format requested.', 'danger')
        return redirect(url_for('dashboard'))

def read_instance_config(config_folder='config', config_file_name='config.yaml'):
    """Read main configuration file from the config folder and return a verified configuration dict"""
    with open(os.path.join(config_folder,config_file_name)) as handle:
        config = yaml.safe_load(handle)
    # TODO: Ensure critical keys available in dict
    return config

def read_uploaded_dataset(file_path, config):
    if file_path.endswith('csv'):
        df = pd.read_csv(file_path)
    elif file_path.endswith('xlsx'):
        df = pd.read_excel(file_path)
    return df
    
def is_valid_filename(filename, config):
    allowed_formats = config['datastore'].get('data_upload').get('allowed_formats', [])
    if '.' in filename and filename.split('.')[-1] in allowed_formats:
        return True
    else:
        return False

def generate_websafe_session_id(size=8):
    """
    Generate and return a web-safe hexadecimal number of a specific size.
    
    Args:
        size: A positive integer value that specifies the length of the string to be generated
    
    Returns:
        A generated hexadecimal string of the specified size. 
    
    """
    return secrets.token_hex(size)

def scrape_form_content(config_dict):
    """
    Scrape the specified form for field labels, input types and names return them as a dict.
    
    """
    if 'form_html_file' not in config_dict or 'form_id' not in config_dict:
        raise RuntimeError("Please ensure that both the 'form_id' and 'form_html_file' keys are specified in the provided config_dict.")

    form_html_file = config_dict['form_html_file']
    form_id = config_dict['form_id']

    with open(os.path.join('templates',form_html_file),'r') as handle:
        html_doc = handle.read()

    soup = BeautifulSoup(html_doc, 'html.parser')
    form = soup.find('form', id=form_id)
    if not form:
        raise ValueError(f"Form with ID '{form_id}' not found!")

    form_content = []
    for label in form.find_all('label'):
        field_id = label.get('for')
        input_field = form.find(id=field_id)
        if input_field:
            field_info = {
                'field_label': label.text.strip(),
                'field_name': input_field.get('name'),
                'field_type': input_field.name,
                'input_type': input_field.get('type'),
                'is_required': True if 'required' in input_field.attrs else False 
            }
            if input_field.name == 'select':
                field_info['select_options'] = [{'display_text': option.text.strip(), 'backend_value': option.get('value')} for option in input_field.find_all('option')]
            form_content.append(field_info)
    return form_content

def generate_html_table_using_form_content_html(form_content):
    """
    Generate and return an HTML table string to neatly display form_content generated by the scrape_form_content function.

    :param: json_data: A JSON document in the form
            [ 
                {
                    'field_label': '',
                    'field_name': '',
                    'field_type': '',
                    'input_type': '',
                    'is_required': '',
                    'select-options': [
                        {'backend_value': '', 'display_text': ''},
                    ]
                },
                ...    
            ]
            that is generated using the scrape_form_content function.
    :returns: HTML string representing table that can be displayed within a webpage
    """

    html_start="""
    <!-- Unique MD5 for versioning -->
    <p class="text-center text-muted">Version: {md5_string}</p>
    <!-- Form submission table --> 
    <table class="docs table table-responsive table-hover table-striped table-bordered">
        <thead>
            <tr>
                <th>#</th>
                <th>Backend Field Name</th>
                <th>Field Label</th>
                <th>Required?</th>
                <th>Field Type</th>
                <th>Select Options (if applicable)</th>
            </tr>
        </thead>
        <tbody>
    """
    html_end="""
        </tbody>
    </table>
    """

    rows = ""
    for i, field in enumerate(form_content):
        select_options = []
        if field.get('select_options'):
            select_options = [opt['display_text'] for opt in field['select_options']]
        rows += f"""
        <tr>
            <td>{i+1}</td>
            <td>{field['field_name']}</td>
            <td>{field['field_label']}</td>
            <td>{field['is_required']}</td>
            <td>{field['field_type']}</td>
            <td>{', '.join(select_options)}</td>
        </tr>
        """
    # Unique string for each version generated, for file versioning
    md5_string = hashlib.md5(rows.encode()).hexdigest()
    html_content = html_start.format(md5_string=md5_string) + rows + html_end
    return html_content



def ip_info_check(ip_address):
    """
    Return a set of information fields for the specified IP address.

    This method retrieves metadata for the originating IP address of the connecting client (i.e. user IP)
    in order to be used for submission validation. Currently, all details returned by the IPInfo service
    are returned, but future revisions will require a list of keys that should be retrieved.

    Args:
        ip_address: A str containing the target IP address
    Returns:
        A dict containing all metadata fron the IPInfo service for the specified IP
    """
    access_token = 'fe76c819b5c55e' # Registered to avenugop@buffalo.edu
    handler = ipinfo.getHandler(access_token)
    details = handler.getDetails(ip_address).all
    return details

def get_ip_address():
    """
    Return session IP address based on request headers.
    
    Args:
        None
    Returns:
        IP address of the user/client that initiated the request. 
    """
    if request.headers.get('X-Forwarded-For'):
        ip = request.headers.get('X-Forwarded-For').split(',')[0]
    else:
        ip = request.remote_addr
    return ip

def l1_validations(session_info):
    """
    Level-1 validations on session data.
    
    This method performs a set of validations on the provided session metadata 
    and returns a dictionary with results. The list of validations is arbitrary
    and can be found in project documentation.
    
    This method is currently a stub and returns an empty dictionary.
    """
    return {}

def l2_validations(session_info):
    """
    Level-2 validations on session data.

    This method performs a set of validations on the provided session metadata 
    and returns a dictionary with results. The list of validations is arbitrary
    and can be found in project documentation.

    Args:
        session_info: A dict containing session metadata
    Returns:
        A dict containing validations and their results.  
    """
    results = {}
    # Honeypot field modification check
    results['honeypot_validation_pass'] = True if session_info['hpfm'] == 'n' else False
    return results

def l3_validations(session_info):
    """
    Level-3 validations on session data.

    This method performs a set of validations on the provided session metadata 
    and returns a dictionary with results. The list of validations is arbitrary
    and can be found in project documentation.

    Args:
        session_info: A dict containing session metadata
    Returns:
        A dict containing validations and their results.  
    """
    results = {}

    # Elapsed Time validation
    elapsed_time = session_info['elapsed_time']
    results['elapsed_time_validation_pass'] = False if elapsed_time < 15.0 else True 
    # Final model output
    if not results['elapsed_time_validation_pass']: # TODO: Actually implement a model here instead of hardcoding
        results['elapsed_time_validation_pass'] = False
    return results


def send_session_id_reminder_email(destination_address, session_id):
    # Sandbox API URL format: https://api.mailgun.net/v3/sandbox&lt;ID&gt;.mailgun.org/messages
    MAILGUN_API_URL = "https://api.mailgun.net/v3/sandboxf7cf6f2359994397ab1b7a150ce5c6fa.mailgun.org/messages"
    FROM_EMAIL_ADDRESS = "Excited User <mailgun@sandboxf7cf6f2359994397ab1b7a150ce5c6fa.mailgun.org>"
    to_address = destination_address,
    subject = 'reminder'
    message = f"your session id is {session_id}"
    api_key = "98420c6821f675a1c83d5de491df6ced-9c3f0c68-678b2533"

    resp = requests.post(
        MAILGUN_API_URL,
         auth=("api", api_key),
         data={
            "from": FROM_EMAIL_ADDRESS,
            "to": to_address,
            "subject": subject,
            "text": message
        }
    )
    if resp.status_code == 200: # success
        print(f"Successfully sent an email to '{to_address}' via Mailgun API.")
    else: # error
        print(f"Could not send the email, reason: {resp.text}")
